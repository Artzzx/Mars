/**
 * compiler/index.ts — Public entry point for the filter compiler.
 *
 * Pipeline:
 *   UserInput
 *     → resolveContext()         → BuildContext
 *     → lookupKnowledgeProfile() → ResolvedProfile
 *     → applyPrerequisites()     → AffixWeight[] (zeroed)
 *     → allocateRuleBudget()     → RuleSchedule
 *     → generateRules()          → CompiledRule[]
 *     → sort + convert           → ItemFilter
 *     → generateFilterXml()      → string (XML)
 *
 * Two public exports:
 *   compileFilter(input)    → ItemFilter  (structured object)
 *   compileFilterXML(input) → string      (game-ready XML)
 *   compileFilterFull(input)→ CompileResult (metadata + both above)
 */

import {
  FILTER_VERSION,
  GAME_VERSION,
} from '@filter-site/lib/filters/types.js';
import type { ItemFilter } from '@filter-site/lib/filters/types.js';
import { generateFilterXml } from '@filter-site/lib/xml/generator.js';
import { getStrictnessConfig, getDefaultStrictness } from '@filter-site/lib/templates/schemas/strictness.js';

import { loadKnowledgeBase }      from '../loaders/knowledge-base.js';
import { loadRecommendations }    from '../loaders/recommendations.js';
import { resolveContext }         from './context.js';
import { lookupKnowledgeProfile } from './lookup.js';
import { applyPrerequisites }     from './prerequisites.js';
import { allocateRuleBudget }     from './budget.js';
import { generateRules }          from '../rules/index.js';
import { compiledToRule }         from './adapter.js';

import type { UserInput } from '../types/build-context.js';
import type { CompileResult } from '../types/resolved-profile.js';

// Re-export public types
export type { UserInput }    from '../types/build-context.js';
export type { BuildContext } from '../types/build-context.js';
export type { CompileResult } from '../types/resolved-profile.js';

// ---------------------------------------------------------------------------
// Icon / color helpers (mirrors engine.ts, adapted for lowercase baseClass)
// ---------------------------------------------------------------------------

const CLASS_ICONS: Record<string, number> = {
  primalist: 3,
  mage:      2,
  sentinel:  1,
  rogue:     4,
  acolyte:   5,
};

const STRICTNESS_COLORS: Record<string, number> = {
  regular:      12, // green
  strict:        8, // yellow
  'very-strict': 5, // orange
  'uber-strict': 6, // red
  'giga-strict': 14, // purple
};

function getClassIcon(baseClass: string): number {
  return CLASS_ICONS[baseClass] ?? 1;
}

function getStrictnessColor(strictnessId: string): number {
  return STRICTNESS_COLORS[strictnessId] ?? 12;
}

function makeFilterName(baseClass: string, mastery: string, strictnessId: string): string {
  const strictness = getStrictnessConfig(strictnessId) ?? getDefaultStrictness();
  const masteryLabel = mastery
    .split('_')
    .map(w => w.charAt(0).toUpperCase() + w.slice(1))
    .join(' ');
  return `${masteryLabel} ${strictness.name} Filter`;
}

function makeFilterDescription(
  mastery: string,
  phase: string,
  damageTypes: string[],
  strictnessId: string,
  matchedBuilds: string[],
  specificityScore: number,
  confidence: string,
): string {
  const strictness = getStrictnessConfig(strictnessId) ?? getDefaultStrictness();
  const dtLabel = damageTypes.length > 0 ? damageTypes.join(', ') : 'generic';
  const buildLabel = matchedBuilds.length > 0 ? matchedBuilds.join(', ') : 'baseline';
  return [
    strictness.description,
    `\n\nBuild: ${mastery} | Phase: ${phase} | Damage: ${dtLabel}.`,
    `Matched: ${buildLabel}.`,
    `Specificity: ${(specificityScore * 100).toFixed(0)}% (${confidence} confidence).`,
    `\n\nGenerated by the Last Epoch Filter Compiler.`,
  ].join(' ');
}

// ---------------------------------------------------------------------------
// Public API
// ---------------------------------------------------------------------------

/**
 * Full compilation pipeline. Returns a structured ItemFilter object.
 */
export function compileFilter(input: UserInput): ItemFilter {
  const kb   = loadKnowledgeBase();
  const recs = loadRecommendations();

  const ctx             = resolveContext(input);
  const profile         = lookupKnowledgeProfile(ctx, kb, recs);
  const filteredAffixes = applyPrerequisites(profile.phaseAffixes, ctx);
  const schedule        = allocateRuleBudget(ctx, profile, filteredAffixes);
  const compiled        = generateRules(schedule, ctx, profile, filteredAffixes);

  compiled.sort((a, b) => a.order - b.order);

  return {
    name:                  makeFilterName(ctx.baseClass, ctx.mastery, ctx.strictnessId),
    filterIcon:            getClassIcon(ctx.baseClass),
    filterIconColor:       getStrictnessColor(ctx.strictnessId),
    description:           makeFilterDescription(
                             ctx.mastery, ctx.phase, ctx.damageTypes, ctx.strictnessId,
                             profile.matchedBuilds, profile.specificityScore, profile.confidence,
                           ),
    lastModifiedInVersion: GAME_VERSION.CURRENT,
    lootFilterVersion:     FILTER_VERSION.CURRENT,
    rules:                 compiled.map(compiledToRule),
  };
}

/**
 * Full compilation pipeline. Returns the filter as a game-ready XML string.
 */
export function compileFilterXML(input: UserInput): string {
  return generateFilterXml(compileFilter(input));
}

/**
 * Full compilation pipeline. Returns structured metadata alongside filter and XML.
 * Useful for CLI output and diagnostic tooling.
 */
export function compileFilterFull(input: UserInput): CompileResult {
  const kb   = loadKnowledgeBase();
  const recs = loadRecommendations();

  const ctx             = resolveContext(input);
  const profile         = lookupKnowledgeProfile(ctx, kb, recs);
  const filteredAffixes = applyPrerequisites(profile.phaseAffixes, ctx);
  const schedule        = allocateRuleBudget(ctx, profile, filteredAffixes);
  const compiled        = generateRules(schedule, ctx, profile, filteredAffixes);

  compiled.sort((a, b) => a.order - b.order);

  const filter: ItemFilter = {
    name:                  makeFilterName(ctx.baseClass, ctx.mastery, ctx.strictnessId),
    filterIcon:            getClassIcon(ctx.baseClass),
    filterIconColor:       getStrictnessColor(ctx.strictnessId),
    description:           makeFilterDescription(
                             ctx.mastery, ctx.phase, ctx.damageTypes, ctx.strictnessId,
                             profile.matchedBuilds, profile.specificityScore, profile.confidence,
                           ),
    lastModifiedInVersion: GAME_VERSION.CURRENT,
    lootFilterVersion:     FILTER_VERSION.CURRENT,
    rules:                 compiled.map(compiledToRule),
  };

  return {
    filter,
    xml:              generateFilterXml(filter),
    confidence:       profile.confidence,
    specificityScore: profile.specificityScore,
    matchedBuilds:    profile.matchedBuilds,
    rulesGenerated:   filter.rules.length,
    affixesDropped:   schedule.affixesDropped,
  };
}
