classDiagram
direction TB

%% ============================================================
%% GAME KNOWLEDGE — Static TypeScript constants (never changes at runtime)
%% ============================================================

namespace GameKnowledge {

    class AffixDefinition {
        +int id
        +str name
        +str display_name
        +str category
        +List~str~ valid_slots
        +List~str~ valid_classes
        +str damage_type
        +str classification_source
        +bool is_class_gated
        +is_damage_locked() bool
    }

    class AffixClassificationOverride {
        +int affix_id
        +str damage_type
        +bool is_damage_locked
        +str reason
    }

    class ThresholdAffix {
        +int affix_id
        +str name
        +int cap
        +int show_min_tier
        +bool user_controllable
        +str applies_to_phases
    }

    class ThresholdAffixRegistry {
        +List~ThresholdAffix~ thresholds
        +get_all() List~ThresholdAffix~
        +get_controllable() List~ThresholdAffix~
        +is_threshold(int) bool
    }

}

note for AffixDefinition "Hybrid classification:\n1. Programmatic name-match\n2. Manual override (~30-50 entries)\nDefault = unclassified (safe, shown to all)"

note for ThresholdAffix "Bypasses weight system entirely.\nResistances (cap 75%), endurance.\nUser-toggleable in compiler."

%% ============================================================
%% AFFIX GRAPH — SYNERGY + PREREQUISITE edges only
%% ============================================================

namespace AffixGraph {

    class AffixNode {
        +int affix_id
        +str name
        +str category
        +float base_weight
    }

    class AffixEdge {
        +str edge_type
        +float strength
        +str condition
    }

    class AffixRelationshipGraph {
        +Dict~int_AffixNode~ nodes
        +List~AffixEdge~ edges
        +add_node(AffixNode)
        +add_edge(int, int, str, float)
        +get_synergies(int) List~AffixNode~
        +get_prerequisites(int) List~AffixNode~
        +propagate_weights(Dict) Dict
        +get_subgraph(List~int~) AffixRelationshipGraph
    }

}

note for AffixEdge "SYNERGY: boost connected affix weight\nPREREQUISITE: zero weight if condition unmet\nNo CONFLICT — LE prevents double-rolling by game rule"

%% ============================================================
%% INHERITANCE HIERARCHY — Layer 0 to 4
%% ============================================================

namespace InheritanceHierarchy {

    class InheritanceNode {
        <<abstract>>
        +str node_id
        +str layer
        +Dict~int_float~ weight_overrides
        +Dict~int_int~ min_tier_overrides
        +Dict~int_str~ category_overrides
        +resolve() Dict~int_AffixWeight~
        +merge_into(InheritanceNode) InheritanceNode
    }

    class UniversalBaseline {
        +Dict UNIVERSAL_WEIGHTS
        +resolve() Dict~int_AffixWeight~
    }

    class DamageTypeProfile {
        +str damage_type
        +List~int~ primary_affixes
        +List~int~ synergy_affixes
        +resolve() Dict~int_AffixWeight~
    }

    class ClassProfile {
        +str class_name
        +List~str~ masteries
        +List~str~ item_affinities
        +resolve() Dict~int_AffixWeight~
    }

    class MasteryProfile {
        +str mastery_name
        +str parent_class
        +List~int~ signature_affixes
        +resolve() Dict~int_AffixWeight~
    }

    class BuildOverride {
        +str build_slug
        +str parent_mastery
        +float specificity_score
        +resolve() Dict~int_AffixWeight~
    }

    class InheritanceResolver {
        +UniversalBaseline baseline
        +Dict~str_DamageTypeProfile~ damage_profiles
        +Dict~str_ClassProfile~ class_profiles
        +Dict~str_MasteryProfile~ mastery_profiles
        +AffixRelationshipGraph graph
        +resolve(str, str, str) Dict~int_AffixWeight~
        +walk_hierarchy(str) List~InheritanceNode~
        +apply_graph_propagation(Dict) Dict
        +compute_specificity_layer(str) str
    }

}

%% ============================================================
%% DATA MODELS — Pipeline data shapes
%% ============================================================

namespace DataModels {

    class SourceScope {
        <<enumeration>>
        SINGLE_BUILD
        SINGLE_MASTERY
        MULTI_MASTERY
        FULL_CLASS
    }

    class RawSource {
        +str source_id
        +str url
        +str source_type
        +str build_slug
        +str mastery
        +str damage_type
        +str patch_version
        +datetime ingested_at
        +SourceScope scope
        +List~str~ covered_masteries
        +Dict raw_data
    }

    class SourceQualityScore {
        +float specificity
        +float affix_coverage
        +float phase_coverage
        +float consensus_alignment
        +float recency
        +float overall
        +bool passes_hard_rejection
        +List~str~ rejection_reasons
    }

    class ExtractedWeight {
        +int affix_id
        +str affix_name
        +float raw_weight
        +int min_tier
        +str category
        +str phase
        +str derivation_method
        +float confidence
    }

    class ConsensusWeight {
        +int affix_id
        +float final_weight
        +int min_tier
        +str category
        +int source_count
        +float consensus_spread
        +float confidence
        +List~str~ contributing_sources
    }

    class BuildKnowledgeProfile {
        +str build_slug
        +str mastery
        +str damage_type
        +float specificity_score
        +int source_count
        +str confidence_level
        +str data_source_layer
        +Dict~str_List~ConsensusWeight~~ phases
        +str patch_version
        +datetime generated_at
    }

}

note for SourceScope "MULTI_MASTERY not rejected.\nspecificity = 1 / len(covered_masteries)\nDiluted contribution per mastery."

%% ============================================================
%% INGESTION — Source readers
%% ============================================================

namespace Ingestion {

    class SourceIngester {
        <<abstract>>
        +str source_type
        +ingest(str) RawSource
        +validate_structure(Dict) bool
        +extract_metadata(Dict) Dict
        +detect_scope(Dict) SourceScope
    }

    class PlannerIngester {
        +str source_type = "planner"
        +ingest(str) RawSource
        +parse_export_json(Dict) Dict
        +extract_phase_data(Dict) Dict
        +extract_item_slots(Dict) Dict
    }

    class FilterIngester {
        +str source_type = "community_filter"
        +ingest(str) RawSource
        +parse_xml(str) Dict
        +extract_strictness_levels(Dict) Dict
        +detect_build_target(Dict) str
    }

}

%% ============================================================
%% VALIDATION — Quality gate
%% ============================================================

namespace Validation {

    class SourceValidator {
        +int MIN_UNIQUE_AFFIXES = 15
        +validate(RawSource) SourceQualityScore
        +run_hard_rejection(RawSource) Tuple~bool_List~str~~
        +score_specificity(RawSource) float
        +score_affix_coverage(RawSource) float
        +score_phase_coverage(RawSource) float
        +score_recency(RawSource) float
        +detect_copied_source(RawSource) bool
        +compute_scope_dilution(RawSource) float
    }

}

note for SourceValidator "Hard reject: fewer than 15 affixes,\nunknown IDs, no phase data, detected copy.\nMulti-mastery: diluted, never rejected."

%% ============================================================
%% EXTRACTION — Weight derivation per source type
%% ============================================================

namespace Extraction {

    class AffixResolver {
        +Dict~str_AffixDefinition~ affix_map
        +float MATCH_THRESHOLD = 0.85
        +resolve(str) AffixDefinition
        +fuzzy_match(str) Tuple~AffixDefinition_float~
        +batch_resolve(List~str~) Dict~str_AffixDefinition~
        +apply_overrides(AffixDefinition) AffixDefinition
        +log_unresolved(str)
    }

    class WeightExtractor {
        <<abstract>>
        +AffixResolver resolver
        +ThresholdAffixRegistry thresholds
        +extract(RawSource) List~ExtractedWeight~
        +translate_to_category(float) str
        +skip_if_threshold(int) bool
    }

    class PlannerWeightExtractor {
        +TIER_WEIGHT_MAP Dict
        +ASYMMETRIC_PHASE_MULTIPLIERS Dict
        +extract(RawSource) List~ExtractedWeight~
        +translate_tier(int) float
        +apply_phase_persistence(List, Dict) List~ExtractedWeight~
        +derive_min_tier(int) int
    }

    class FilterWeightExtractor {
        +STRICTNESS_CATEGORY_MAP Dict
        +extract(RawSource) List~ExtractedWeight~
        +infer_from_strictness_survival(Dict) List~ExtractedWeight~
        +extract_min_tier_from_condition(Dict) int
        +extract_rule_structure_signals(Dict) Dict
    }

}

note for PlannerWeightExtractor "Primary source for weight + min_tier.\nAsymmetric phase multipliers:\nBiS-only=x1.0  Starter-only=x0.8  All=x1.0"

note for FilterWeightExtractor "Primary source for category calibration.\nStrictness survival -> essential/strong/useful/filler\nNOT used for absolute weight values."

%% ============================================================
%% CONSENSUS — Multi-source merging
%% ============================================================

namespace Consensus {

    class ConsensusEngine {
        +float LOW_CONFIDENCE_THRESHOLD = 0.4
        +int MIN_SOURCES_FOR_OVERRIDE = 3
        +merge(List~ExtractedWeight~, List~SourceQualityScore~) List~ConsensusWeight~
        +compute_weighted_average(List, List) float
        +detect_outliers(List~float~) List~int~
        +compute_spread(List~float~) float
        +clamp_low_confidence(ConsensusWeight, InheritanceNode) ConsensusWeight
        +assign_final_category(float, List~str~) str
    }

}

%% ============================================================
%% ORCHESTRATION — Pipeline runner and config
%% ============================================================

namespace Orchestration {

    class IngestionPipeline {
        +List~SourceIngester~ ingesters
        +SourceValidator validator
        +WeightExtractor extractor
        +ConsensusEngine consensus
        +InheritanceResolver inheritance
        +ThresholdAffixRegistry thresholds
        +KnowledgeBaseWriter writer
        +PipelineConfig config
        +run(List~str~)
        +run_single(str, str)
        +process_build(str, List~RawSource~) BuildKnowledgeProfile
        +generate_pipeline_report() PipelineReport
    }

    class PipelineConfig {
        +str patch_version
        +float min_quality_threshold
        +bool force_rebuild
        +List~str~ target_builds
        +str output_path
        +bool enable_graph_propagation
    }

    class PipelineReport {
        +int builds_processed
        +int builds_failed
        +int sources_accepted
        +int sources_rejected
        +List~str~ low_confidence_builds
        +Dict warnings
        +datetime generated_at
    }

    class KnowledgeBaseWriter {
        +str output_path
        +str meta_path
        +write(List~BuildKnowledgeProfile~)
        +validate_output(Dict) bool
        +generate_checksum(Dict) str
        +write_meta(Dict)
        +compare_with_previous(Dict) Dict
    }

}

%% ============================================================
%% RELATIONSHIPS — Within namespaces
%% ============================================================

ThresholdAffixRegistry "1" --> "*" ThresholdAffix : contains
AffixDefinition --> AffixClassificationOverride : classified by

AffixRelationshipGraph "1" --> "*" AffixNode : contains
AffixRelationshipGraph "1" --> "*" AffixEdge : contains
AffixEdge --> AffixNode : connects

InheritanceNode <|-- UniversalBaseline
InheritanceNode <|-- DamageTypeProfile
InheritanceNode <|-- ClassProfile
InheritanceNode <|-- MasteryProfile
InheritanceNode <|-- BuildOverride
MasteryProfile --> ClassProfile : inherits from
BuildOverride --> MasteryProfile : inherits from
InheritanceResolver --> UniversalBaseline : walks
InheritanceResolver --> DamageTypeProfile : walks
InheritanceResolver --> ClassProfile : walks
InheritanceResolver --> MasteryProfile : walks
InheritanceResolver --> AffixRelationshipGraph : propagates

RawSource --> SourceScope : tagged with
SourceIngester <|-- PlannerIngester
SourceIngester <|-- FilterIngester
SourceIngester --> SourceScope : assigns

WeightExtractor <|-- PlannerWeightExtractor
WeightExtractor <|-- FilterWeightExtractor
WeightExtractor --> AffixResolver : uses
AffixResolver --> AffixClassificationOverride : applies

%% ============================================================
%% DATA FLOW — Cross-namespace pipeline sequence
%% ============================================================

SourceIngester --> RawSource : produces
SourceValidator --> RawSource : evaluates
SourceValidator --> SourceQualityScore : produces
WeightExtractor --> RawSource : reads
WeightExtractor --> ExtractedWeight : produces
WeightExtractor --> ThresholdAffixRegistry : consults
ConsensusEngine --> ExtractedWeight : merges
ConsensusEngine --> ConsensusWeight : produces
InheritanceResolver --> ConsensusWeight : enriches
KnowledgeBaseWriter --> BuildKnowledgeProfile : writes

IngestionPipeline --> PipelineConfig : configured by
IngestionPipeline --> PipelineReport : produces
IngestionPipeline --> SourceIngester : uses
IngestionPipeline --> SourceValidator : uses
IngestionPipeline --> WeightExtractor : uses
IngestionPipeline --> ConsensusEngine : uses
IngestionPipeline --> InheritanceResolver : uses
IngestionPipeline --> ThresholdAffixRegistry : uses
IngestionPipeline --> KnowledgeBaseWriter : uses
